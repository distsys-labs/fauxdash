type AnyRecord = Record<string, any> | null | undefined;
declare function any<T>(list: T[], predicate?: (value: T) => boolean): boolean;
declare function applyWhen<T>(fn: (...args: any[]) => T | Promise<T>, args?: unknown[]): T | Promise<T>;
declare function bindAll<T extends object>(obj: T): void;
declare function clone<T>(source: T, target?: T): T;
declare function contains<T>(list: T[] | null | undefined, value: T): boolean;
declare function defaults<T extends AnyRecord>(target: T, ...sources: Array<Partial<T>>): T;
declare function each<T extends AnyRecord>(obj: T, iterator: (value: any, key: string, index: number) => void): void;
declare function exists(x: unknown): boolean;
declare function filter<T>(list: T[], predicate?: (value: T) => boolean): T[];
declare function find<T>(list: T[], predicate?: (value: T) => boolean): T | undefined;
declare function flatten<T>(list: Array<T | T[]>): T[];
declare function future<T = void>(): {
    promise: Promise<T>;
    resolve: (value: T | PromiseLike<T>) => void;
    reject: (reason?: any) => void;
};
declare function getArguments(fn: Function): string[];
declare function getObjectTag(value: any): string;
declare function has(obj: AnyRecord | null | undefined, key: string): boolean;
declare function intersection<T>(a: T[], b: T[]): T[];
declare function isDate(value: any): boolean;
declare function isEmpty(value: any): boolean;
declare function isEqual(a: any, b: any): boolean;
declare function isFunction(value: any): boolean;
declare function isNumber(value: any): boolean;
declare function isObject(value: any): boolean;
declare function isPlainObject(value: any): boolean;
declare function isPromisey(x: any): boolean;
declare function isStub(value: any): boolean;
declare function isString(value: any): boolean;
declare function last<T>(list: T[] | null | undefined): T | undefined;
declare function lift<T>(asyncFn: (...args: any[]) => void): (...params: any[]) => Promise<T>;
declare function map<T extends AnyRecord, R>(obj: T, fn: (value: T[keyof T], key: string, index: number) => R): R[];
declare function mapCall(method: (...args: any[]) => any, map: Record<string, string> | true | false): (actor: any, message: any) => any;
declare function matches<T>(filterValue: T): (value: T) => boolean;
declare function melter<T extends AnyRecord>(target: T | null | undefined, ...args: AnyRecord[]): T;
declare function memoize<T extends (...args: any[]) => any>(fn: T): (...args: Parameters<T>) => ReturnType<T>;
declare function merge(...objects: AnyRecord[]): AnyRecord | null | undefined;
declare function omit<T extends AnyRecord>(obj: T, ...keys: Array<string | string[]>): AnyRecord;
declare function noop(): void;
declare function parseFunction(fn: Function): {
    name: string | undefined;
    arguments: string[];
    body: string | undefined;
};
declare function reduce<T extends AnyRecord, R>(obj: T, fn: (acc: R, value: T[keyof T], key: string, index: number) => R, acc: R): R;
declare function sequence(...args: Array<(() => any) | Array<() => any>>): Promise<any[]>;
declare function sortBy<T extends AnyRecord>(list: T[], prop: string): T[];
declare function transform<T extends AnyRecord>(obj: T, aliases: Record<string, string>, ...omitKeys: Array<string | string[]>): AnyRecord;
declare function trimString(str: string | null | undefined): string;
declare function trim(list: Array<string | null | undefined>): string[];
declare function type(obj: any): string;
declare function uniq<T>(original: T[]): T[];
declare function unique<T, I>(list: T[], identity?: (item: T) => I): T[];
declare function values<T extends AnyRecord>(obj: T): Array<T[keyof T]>;
declare function without<T>(a: T[], b: T[]): T[];
export { any, applyWhen, bindAll, contains, clone, defaults, each, exists, find, filter, flatten, future, getArguments, getObjectTag, has, intersection, isDate, isEmpty, isEqual, isFunction, isNumber, isObject, isPlainObject, isPromisey, isStub, isString, last, lift, map, mapCall, matches, melter, memoize, merge, omit, noop, parseFunction, reduce, sequence, sortBy, transform, trim, trimString, type, uniq, unique, values, without };
