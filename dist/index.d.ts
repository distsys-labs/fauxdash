type AnyRecord = Record<string, any> | null | undefined;
declare function any<T>(list: T[], predicate?: (value: T) => boolean): boolean;
declare function applyWhen<T>(fn: (...args: any[]) => T | Promise<T>, args?: unknown[]): T | Promise<T>;
declare function bindAll<T extends object>(obj: T): void;
declare function clone<T>(source: T, target?: T): T;
declare function contains<T>(list: T[] | null | undefined, value: T): boolean;
declare function defaults<T extends AnyRecord>(target: T, ...sources: Array<Partial<T>>): T;
declare function each<T extends AnyRecord>(obj: T, iterator: (value: any, key: string, index: number) => void): void;
declare function exists(x: unknown): boolean;
declare function filter<T>(list: T[], predicate?: (value: T) => boolean): T[];
declare function find<T>(list: T[], predicate?: (value: T) => boolean): T | undefined;
declare function flatten<T>(list: Array<T | T[]>): T[];
declare function future<T = void>(): {
    promise: Promise<T>;
    resolve: (value: T | PromiseLike<T>) => void;
    reject: (reason?: any) => void;
};
declare function getArguments(fn: Function): string[];
declare function getObjectTag(value: any): string;
declare function has(obj: AnyRecord | null | undefined, key: string): boolean;
declare function intersection<T>(a: T[], b: T[]): T[];
declare function isDate(value: any): boolean;
declare function isEmpty(value: any): boolean;
declare function isEqual(a: any, b: any): boolean;
declare function isFunction(value: any): boolean;
declare function isNumber(value: any): boolean;
declare function isObject(value: any): boolean;
declare function isPlainObject(value: any): boolean;
declare function isPromisey(x: any): boolean;
declare function isStub(value: any): boolean;
declare function isString(value: any): boolean;
declare function last<T>(list: T[] | null | undefined): T | undefined;
declare function lift<T>(asyncFn: (...args: any[]) => void): (...params: any[]) => Promise<T>;
declare function map<T extends AnyRecord, R>(obj: T, fn: (value: T[keyof T], key: string, index: number) => R): R[];
declare function mapCall(method: (...args: any[]) => any, map: Record<string, string> | true | false): (actor: any, message: any) => any;
declare function matches<T>(filterValue: T): (value: T) => boolean;
declare function melter<T extends AnyRecord>(target: T | null | undefined, ...args: AnyRecord[]): T;
declare function memoize<T extends (...args: any[]) => any>(fn: T): (...args: Parameters<T>) => ReturnType<T>;
declare function merge(...objects: AnyRecord[]): AnyRecord | null | undefined;
declare function omit<T extends AnyRecord>(obj: T, ...keys: Array<string | string[]>): AnyRecord;
declare function noop(): void;
declare function parseFunction(fn: Function): {
    name: string | undefined;
    arguments: string[];
    body: string | undefined;
};
declare function reduce<T extends AnyRecord, R>(obj: T, fn: (acc: R, value: T[keyof T], key: string, index: number) => R, acc: R): R;
declare function sequence(...args: Array<(() => any) | Array<() => any>>): Promise<any[]>;
declare function sortBy<T extends AnyRecord>(list: T[], prop: string): T[];
declare function transform<T extends AnyRecord>(obj: T, aliases: Record<string, string>, ...omitKeys: Array<string | string[]>): AnyRecord;
declare function trimString(str: string | null | undefined): string;
declare function trim(list: Array<string | null | undefined>): string[];
declare function type(obj: any): string;
declare function uniq<T>(original: T[]): T[];
declare function unique<T, I>(list: T[], identity?: (item: T) => I): T[];
declare function values<T extends AnyRecord>(obj: T): Array<T[keyof T]>;
declare function without<T>(a: T[], b: T[]): T[];
declare const _default: {
    any: typeof any;
    applyWhen: typeof applyWhen;
    bindAll: typeof bindAll;
    contains: typeof contains;
    clone: typeof clone;
    defaults: typeof defaults;
    each: typeof each;
    exists: typeof exists;
    find: typeof find;
    filter: typeof filter;
    flatten: typeof flatten;
    future: typeof future;
    getArguments: typeof getArguments;
    getObjectTag: typeof getObjectTag;
    has: typeof has;
    intersection: typeof intersection;
    isDate: typeof isDate;
    isEmpty: typeof isEmpty;
    isEqual: typeof isEqual;
    isFunction: typeof isFunction;
    isNumber: typeof isNumber;
    isObject: typeof isObject;
    isPlainObject: typeof isPlainObject;
    isPromisey: typeof isPromisey;
    isStub: typeof isStub;
    isString: typeof isString;
    last: typeof last;
    lift: typeof lift;
    map: typeof map;
    mapCall: typeof mapCall;
    matches: typeof matches;
    melter: typeof melter;
    memoize: typeof memoize;
    merge: typeof merge;
    omit: typeof omit;
    noop: typeof noop;
    parseFunction: typeof parseFunction;
    reduce: typeof reduce;
    sequence: typeof sequence;
    sortBy: typeof sortBy;
    transform: typeof transform;
    trim: typeof trim;
    trimString: typeof trimString;
    type: typeof type;
    uniq: typeof uniq;
    unique: typeof unique;
    values: typeof values;
    without: typeof without;
};
export default _default;
